class Guid{constructor(){this._guids=[];this._force=null}create(pattern="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"){let guid;if(!this._force){do{guid=pattern.replace(/[x]/g,(()=>(Math.random()*16|0).toString(16)))}while(this._guids.includes(guid))}else{guid=this._force;this._force=null}this._guids.push(guid);return guid}remove(guid){this._guids=this._guids.filter((item=>item!==guid))}has(guid){if(this._guids.includes(guid))return true;return false}force(guid){if(this.valid(guid))this._force=guid;else throw new Error("not a valid guid")}valid(guid){return/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(guid)}}class Mobile{static isMobile(){if(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)||navigator.userAgent.match(/BlackBerry/i)||navigator.userAgent.match(/IEMobile/i)||navigator.userAgent.match(/Opera Mini/i)||navigator.userAgent.match(/Windows Phone/i))return true;return false}static setMaxWidth(width){const scale=screen.width/width;document.querySelector('meta[name="viewport"]').setAttribute("content","width="+width+", initial-scale="+scale+", user-scalable=no")}}class ExtendedMap{constructor(map){this._map=new Map;if(map)this._map=map}has(name){if(this._map.has(name))return true;else return false}set(name,object){if(!this._map.has(name)){this._map.set(name,{index:this.index(),object});let entry=this._map.get(name);return entry.object}throw new Error("duplicate name in map")}get(name){if(this._map.has(name))return this._map.get(name).object;else return undefined}first(){return this._map.entries().next().value[0]}delete(name){return this._map.delete(name)}index(key,index){let newindex=0;this._map.forEach((object=>{if(object.index==index)throw new Error("duplicate index in map");if(object.index>=newindex)newindex=object.index}));if(key&&index)this._map.get(key).index=index;else return++newindex}sort(){this._sorted=new ExtendedMap(new Map([...this._map.entries()].sort(((a,b)=>a[1].index-b[1].index)).filter(Boolean)))}reverse(){this._sorted=new ExtendedMap(new Map([...this._map.entries()].sort(((a,b)=>b[1].index-a[1].index)).filter(Boolean)))}filter(func){let filtered=[];this._map.forEach(((value,key,map)=>{if(func(value.object,map.get(key).index))filtered.push(value.object)}));return filtered}clear(){if(this._sorted)this._sorted.clear();this._map.clear()}forEach(func){this._map.forEach((value=>{func(value.object)}))}[Symbol.iterator](){const values=this._map.values();let index=-1;return{next:()=>{let done=false;let value;if(++index<this._map.size)value=values.next().value.object;else{value=undefined;done=true}return{value,done}}}}get map(){return this._map}get sorted(){if(!this._sorted)this._sorted=new ExtendedMap;return this._sorted}}class Clipboard{static async getContent(){try{const clipboardItems=await navigator.clipboard.read();for(const clipboardItem of clipboardItems){for(const type of clipboardItem.types){if(type.startsWith("image/")){const blob=await clipboardItem.getType(type);return new Promise(((resolve,reject)=>{const reader=new FileReader;reader.onloadend=()=>{resolve(reader.result)};reader.onerror=reject;reader.readAsDataURL(blob)}))}else if(type.startsWith("text/plain")){const blob=await clipboardItem.getType(type);return await blob.text()}}}}catch(exception){console.error(exception.name,exception.message);console.log("make sure you are using https:// or localhost")}}static setContent(content){try{return new Promise(((resolve,reject)=>{navigator.clipboard.writeText(content).then((()=>{resolve()}),(()=>{reject()}))}))}catch(exception){console.error(exception.name,exception.message);console.log("make sure you are using https:// or localhost")}}}class Keyboard{constructor(element,smuggler){this._keydownCallbacks=new Map([["key",[this.onKeydown]]]);this._keyupCallbacks=new Map([["key",[this.onKeyup]]]);this._element=element;this._smuggler=smuggler||null}enable(){this._keydown=this.handleKeydown.bind(null,this);this._keyup=this.handleUp.bind(null,this);this._element.addEventListener("keydown",this._keydown,false);this._element.addEventListener("keyup",this._keyup,false)}disable(){this._element.removeEventListener("keydown",this._keydown,false);this._element.removeEventListener("keyup",this._keyup,false)}setKeydownCallbacks(callbacks){this._keydownCallbacks=callbacks}setKeyupCallbacks(callbacks){this._keyupCallbacks=callbacks}onKeydown(event,smuggler){}onKeyup(event,smuggler){}filter(event){let input="";const keycode=event.keyCode;const valid=keycode>47&&keycode<58||keycode==32||keycode==13||keycode==35||keycode==36||keycode==8||keycode==9||keycode==46||keycode==27||keycode>36&&keycode<41||keycode>64&&keycode<91||keycode>95&&keycode<112||keycode>185&&keycode<193||keycode>218&&keycode<223;if(event.ctrlKey||!event.ctrlKey&&event.key=="Control"&&event.type=="keyup")input+="ctrl";if(event.shiftKey||!event.shiftKey&&event.key=="Shift"&&event.type=="keyup"){if(input.length>0)input+="+";input+="shift"}if(event.altKey||!event.altKey&&event.key=="Alt"&&event.type=="keyup"){if(input.length>0)input+="+";input+="alt"}if(valid){if(input.length>0)input+="+";if(event.key==="ArrowRight")input+="right";else if(event.key==="ArrowLeft")input+="left";else if(event.key==="ArrowUp")input+="up";else if(event.key==="ArrowDown")input+="down";else if(event.key==="Enter")input+="enter";else if(event.key==="Backspace")input+="backspace";else if(event.key==="Delete")input+="delete";else if(event.key==="Escape")input+="escape";else if(event.key==="Tab")input+="tab";else if(event.key==="Home")input+="home";else if(event.key==="End")input+="end";else if(input==="shift+")input=event.key;else input+=event.key}if(input.length>0)return input;else return null}handleKeydown(keyboard,event){const input=keyboard.filter(event);let callbacks=[];if(input){if(input.length===1)callbacks=keyboard._keydownCallbacks.get("key");else callbacks=keyboard._keydownCallbacks.get(input);if(callbacks){if(callbacks.length!=0){for(let callback of callbacks)callback(event,keyboard._smuggler)}}}}handleUp(keyboard,event){const input=keyboard.filter(event);let callbacks=[];if(input){if(input.length===1)callbacks=keyboard._keyupCallbacks.get("key");else callbacks=keyboard._keyupCallbacks.get(input);if(callbacks){if(callbacks.length!=0){for(let callback of callbacks)callback(event,keyboard._smuggler)}}}}}class WebSocketSecure{constructor(attributes={}){this._guids=new Guid;this._timeoutMs=2e4;this._timeoutId=undefined;this._keepaliveID=undefined;this._parsers=new Map;this._closers=new Map;this._link=attributes.link;if(attributes.initier){this._parsers.set("00000000-0000-0000-0000-000000000000",attributes.initier);this.attachParser(attributes.initier)}if(attributes.parser)this._parser=attributes.parser;else this._parser={callback:(raw,smuggler)=>({success:true,response:raw.response}),smuggler:{}};if(attributes.closer)this.attachCloser(attributes.closer)}attachParser(attachable){let guid=this._guids.create("xxxxxxxx-xxxx-1xxx-8xxx-xxxxxxxxxxxx");this._parsers.set(guid,attachable);return guid}attachCloser(attachable){let guid=this._guids.create("xxxxxxxx-xxxx-1xxx-9xxx-xxxxxxxxxxxx");this._closers.set(guid,attachable);return guid}detach(guid){if(/^.{18}-8/.test(guid))this._parsers.delete(guid);else if(/^.{18}-9/.test(guid))this._closers.delete(guid);this._guids.remove(guid)}isConnected(){if(this._ws){if(this._ws.readyState===1)return true;else return false}else return false}connect(){return new Promise(((resolve,reject)=>{if(this.isConnected()){resolve(true);return}this._ws=new WebSocket(this._link);this._ws.onopen=()=>{this._keepaliveID=setInterval((()=>{if(this.isConnected())this._ws.send(JSON.stringify({query:"keep-alive"}))}),2e4);resolve(true)};this._ws.onmessage=event=>{let message=JSON.parse(event.data);if(this._parsers.has(message.guid))this._parsers.get(message.guid).callback(message,this._parsers.get(message.guid).smuggler)};this._ws.onerror=event=>{clearTimeout(this._timeoutId);reject({status:"wrong",message:"The connection was closed abnormally",data:undefined})};this._ws.onclose=event=>{if(!event.wasClean){let message="Unknown reason";if(event.code==1e3)message="Normal closure";else if(event.code==1001)message='An endpoint is "going away"';else if(event.code==1002)message="An endpoint is terminating the connection due to a protocol error";else if(event.code==1003)message="An endpoint is terminating the connection because it has received a type of data it cannot accept";else if(event.code==1004)message="Reserved";else if(event.code==1005)message="No status code was actually present";else if(event.code==1006)message="The connection was closed abnormally";else if(event.code==1007)message="An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message";else if(event.code==1008)message='An endpoint is terminating the connection because it has received a message that "violates its policy"';else if(event.code==1009)message="An endpoint is terminating the connection because it has received a message that is too big for it to process";else if(event.code==1011)message="A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request";else if(event.code==1015)message="The connection was closed due to a failure to perform a TLS handshake";clearTimeout(this._timeoutId);clearInterval(this._keepaliveID);this._closers.forEach(((value,key,map)=>{value.callback({response:message},value.smuggler)}));reject({status:"wrong",message,data:undefined})}}}))}close(){this._ws.close()}send(payload,attachable){let timeoutPromise=new Promise(((resolve,reject)=>{this._timeoutId=setTimeout((()=>{clearTimeout(this._timeoutId);reject({status:"wrong",message:"Timeout",data:undefined})}),this._timeoutMs)}));let sendPromise=new Promise(((resolve,reject)=>{function bridge(raw,smuggler){let result;if(attachable)result=attachable.callback(raw,smuggler.smuggler);else result=smuggler.default.callback(raw,smuggler.default.smuggler);smuggler.wss.detach(raw.guid);if(result.success===true){resolve(result.response)}else{reject(result.response)}}if(attachable)payload.guid=this.attachParser({callback:bridge,smuggler:{wss:this,smuggler:attachable.smuggler}});else payload.guid=this.attachParser({callback:bridge,smuggler:{wss:this,default:this._parser}});this.connect().then((()=>{this._ws.send(JSON.stringify(payload))})).catch((error=>{this.detach(payload.guid);reject(error)}))}));return Promise.race([sendPromise,timeoutPromise])}setTimeout(ms){this._timeoutMs=ms}static undefined(source){if(Array.isArray(source)){for(let subsource of source){if(subsource===undefined)return true}}else{if(source===undefined)return true}return false}}export{Clipboard,ExtendedMap,Guid,Keyboard,Mobile,WebSocketSecure};